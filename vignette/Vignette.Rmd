---
title: "Tree aggregation"
output: 
  pdf_document:
    toc: true
    toc_depth: 4
    number_sections: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ape)
library(treeAGG)
library(ggtree)
```

\newpage 

In this Vignette, I use the data generated by Lukas as an example to show how to use the **treeAGG** package. 


## Data preparation
### The tree 


The tree data created by Lukas from the cytometry data is a hclust object. To use treeAGG, we need to firstly transform it into a phylo object.


```{r}
data("hclust_out")
class(hclust_out)
phylo_out <- as.phylo(hclust_out)
class(phylo_out)
```


We further prune the tree at each internal node into subtrees. The results are output as a list of phylo objects, each representing a subtree. This step is not obligatory. The list of subtrees is required later for tree aggregation. It could be generated automatically in the aggregation R functions, but the cutting could take a lot of time if the tree has huge size. To run it once and save it for later use would save a lot of time.

```{r}
# prune tree
system.time(
phylo_small <- pruneTree(phylo_out)
)

```


### The count table

A count table with each row representing a node in the tree and each column representing a sample is required. If data only provides the count at tree leaf nodes, we could use the following code to generate a count table for the whole tree.

```{r}
data("res_table")
head(res_table)

# generate the count table for the leaf nodes
tipCount <- res_table[, c(grep("healthy_", colnames(res_table)),
                          grep("CN_H", colnames(res_table)))]
rownames(tipCount) <- res_table$cluster
dim(tipCount)

# generate the count table for the whole tree (including leaves and internal nodes)
# the count of an internal node is the sum of counts on its descendant leaves.
allCount <- nodeCount(tipTable = tipCount, wtree = phylo_out,
                      stree = phylo_small, fun = sum)
dim(allCount)
```


## Data analysis

We arrange the hypothesis in a tree-like structure and test hypotheses
$H_0 : \text{There is not differential abundance}$ at each node (interal node and leaf node) of the tree.

R package **edgeR** is used here to investigate whether an entity has differential abundance among conditions. Users are free to choose other R packages to do the analysis. Finally, we obtain a p value at each node of the tree and further use them to do tree aggregation.
 
```{r}
library(edgeR)
isNode <- grepl("Node", rownames(allCount))
mod_edgeR <- Redge(countTab = allCount, nSam = c(5,5), 
                   isTip = !isNode, isAnalyze = rep(TRUE, nrow(allCount)),
                   prior.count = 0, normalize = TRUE)
head(mod_edgeR)
```

The output has multiple columns, one of which is the adjusted p value named \textit{FDR}. The adjusted p value is obtained via Benjamin-Hochberg method. We could directly use the $mod\_edgeR$ to do the tree aggregation in the next section or extract only the column \textit{FDR}.

## Tree aggregation

To do tree aggregation, we need a hiearchical tree ($phylo\_out$), and a matrix or data frame with a column of adjusted p vlaues at each node of the tree ($mod\_edgeR$). The subtrees of the hiearchical tree (phylo_small) could be provided to save time. If stree is set as NULL, the list of subtrees would be generated automatically.


```{r}
# min - P
loc_edgeR <- treeAGG(wtree = phylo_out, data = mod_edgeR,
                     stree = phylo_small, P.lim = 0.05, 
                     varSIG = "FDR", varAGG = "FDR")

```

* Item 1 wtree is the hiearchical tree of the entities (such as OTUs or cells).
* Item 2 data is the data frame including at least a column of adjusted p values for all nodes of hiearchical tree.
* Item 3 stree is a list of subtrees of the hiearchical tree.
* Item 4 P.lim is the significant threshold value for the adjusted p value.
* Item 5 varSIG is the column name of the adjusted p value.
* Item 6 varAGG is the column name of the variable the aggregation based on. Here, we also use the adjusted p value.

## Result visualisation

```{r}
trueTip <- as.character(res_table$cluster[res_table$true])
real <- signalFind(node = trueTip, tree = phylo_out, label = TRUE)

p <- treePlot(tree = phylo_out,  
              branch = real,
              col.branch = c("Diff" = "blue"), 
              col.other = c("Non-diff" = "darkgrey"),
              size.point = 2, 
              size.line.legend = 2,
              size.point.legend = 2,  
              point = loc_edgeR,
              col.point = c(found = "orange"),
              zoomNode = real, 
              zoomScale = 8,
              legend.title = c("point" = "Estimate",
                               "branch" = "Truth"),
              layout = "circular")

p+
  ggplot2::theme(legend.position = "right",
                 legend.text = element_text(size= 12),
                 legend.key.size = unit(4,"cm"),
                 legend.key.height = unit(0.4,"cm"),
                 legend.key.width = unit(0.5, "cm"),
                 legend.title = element_text(size = 15),
                 legend.background = element_rect(),
                 legend.box.background = element_rect(colour = "black"))


```
