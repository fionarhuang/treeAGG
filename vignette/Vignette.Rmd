---
title: "Tree aggregation"
output: 
  pdf_document:
    toc: true
    number_sections: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ape)
library(treeAGG)
library(ggtree)
```

In this Vignette, I use the data generated by Lukas as an example to show how to use the treeAGG package. 


## Data preparation
### The tree 


The tree data created by Lukas from the cytometry data is a hclust object. To use treeAGG, we need to firstly transform it into a phylo object.


```{r}
data("hclust_out")
class(hclust_out)
phylo_out <- as.phylo(hclust_out)
class(phylo_out)
```


The tree is pruned at each internal node into subtrees. The results are output as a list of phylo objects, each representing a subtree. 

```{r}
# prune tree
system.time(
phylo_small <- pruneTree(phylo_out)
)

```


## The count table

In this section, we would like to prepare a count table with each row representing a node in the tree and each column representing a sample. If the data only provides the count table of tree leaves, we could use the following code to generate the count table for the whole tree.

```{r}
data("res_table")
head(res_table)

# the count table for the leaves
tipCount <- res_table[, c(grep("healthy_", colnames(res_table)),
                          grep("CN_H", colnames(res_table)))]
rownames(tipCount) <- res_table$cluster
dim(tipCount)

# the count table for the whole tree (including leaves and internal nodes)
# the count of an internal node is the sum of counts on its descendant leaves.
allCount <- nodeCount(tipTable = tipCount, wtree = phylo_out,
                      stree = phylo_small)
dim(allCount)
```


## Data analysis

We arrange the hypothesis in a tree-like structure and test hypotheses
$H_0 : \text{there is no abundance difference among conditions}$ at all nodes (interal nodes and leaves) of the tree.

To investigate whether the entities have differential abundance among conditions, R package edgeR is used here. Users are free to choose any R packages to do the analysis. At the end, we only need the p values for each node on the tree and further use them to do tree aggregation.
 
```{r}
library(edgeR)
isNode <- grepl("Node", rownames(allCount))
mod_edgeR <- Redge(countTab = allCount, nSam = c(5,5), 
                   isTip = !isNode, isAnalyze = rep(TRUE, nrow(allCount)),
                   prior.count = 0, normalize = TRUE)
head(mod_edgeR)
```

The output has multiple columns, one of which is the adjusted p value named \textit{FDR}. The adjusted p value is obtained via Benjamin-Hochberg method. We could directly use the $mod\_edgeR$ to do the tree aggregation in the next section or extract only the column \textit{FDR}.

## Tree aggregation

To do tree aggregation, we need to provide a hiearchical tree ($phylo\_out$), its subtrees ($phylo\_small$) and a matrix or data frame with a column of adjusted p vlaues at each node of the tree ($mod\_edgeR$). 


```{r}
# min - P
loc_edgeR <- treeAGG(wtree = phylo_out, ResTipNode = mod_edgeR,
                     stree = phylo_small, P.lim = 0.05, 
                     VarSig = "FDR", VarAGG = "FDR")

```

* Item 1 wtree is the hiearchical tree of the entities (such as OTUs or cells).
* Item 2 ResTipNode is the data frame including at least a column of adjusted p values for all nodes of hiearchical tree.
* Item 3 stree is a list of subtrees of the hiearchical tree.
* Item 4 P.lim is the significant threshold value for the adjusted p value.
* Item 5 VarSig is the column name of the adjusted p value.
* Item 6 VarAGG is the column name of the variable the aggregation based on. Here, we also use the adjusted p value.

## Result visualisation



```{r}
trueTip <- as.character(res_table$cluster[res_table$true])
real <- signalFind(node = trueTip, tree = phylo_out, label = TRUE)

p <- treePlot(tree = phylo_out, trueLoc = real[1], level = 2, 
         zoomScale = 10, col.trueLoc = "blue", 
         col.other = c("non-diff" = "grey"), layout = "circular", 
         aggLoc = loc_edgeR, col.aggLoc = c("found"="black")) 

p+
  ggplot2::theme(legend.position = "right",
                 legend.text = element_text(size= 12),
                 legend.key.size = unit(4,"cm"),
                 legend.key.height = unit(0.6,"cm"),
                 legend.key.width = unit(0.6, "cm"),
                 legend.title = element_text(size = 15))

```
