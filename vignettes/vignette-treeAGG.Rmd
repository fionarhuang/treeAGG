---
title: "Tree Aggregation"
author: 
- name: Ruizhu HUANG
  affiliation: 
  - Institute of Molecular Life Sciences, University of Zurich.
  - SIB Swiss Institute of Bioinformatics.
- name: Charlotte Soneson
  affiliation: 
  - Institute of Molecular Life Sciences, University of Zurich.
  - SIB Swiss Institute of Bioinformatics.
- name: Mark Robinson
  affiliation: 
  - Institute of Molecular Life Sciences, University of Zurich.
  - SIB Swiss Institute of Bioinformatics.
package: treeAGG
output: 
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Tree Aggregation}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: treeAGG_vignette.bib
---




```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```
# Introduction

The arrangement of hypotheses in a hierarchical structure appears in many research fields and often indicates different resolutions at which data can be viewed. On which resolution level should the signal be intepreted has arisen researchers' interest. For example, the association between a phenotypic outcome (e.g., diseased and healthy) and abundance changes of entities (e.g., microbes or cells) might be of interest. However, the abundance change on the entity level might not be evident due to the low abundance even though it does exist. It might become evident at a higher hierarchical level, which represents a cluster of entities, due to the accumulation caused by the similarity in response to the environment shared by the entities in the same cluster. 

On which hierarchical level should the change be tested becomes a critical question to be answered. A flexible method to select hierarchical level, instead of cutting the tree structure at arbitary levels, is desired. Our package treeAGG, which uses the minP algorithm, is a such tool. It does a bottom-up search for the optimal level of a tree to interpret signal by integrating two types of data: abundance estimate of a set of entities (e.g., microbes or cells) across a set of samples (e.g., diseased and healthy) and a tree that encodes a hierarchical relationship among the entities (e.g., a phylogeny of microbes). It could flexibly combine with current available tools, such as edgeR or DESeq2.



# Method

Consider the case in which a count table and a tree of $n$ entities (e.g. microbes or cells) are available. The goal is to find the hierarchical level of the tree on which the association should be intepreted. Each row of the count table represents an entity $g$. Each column is a sample. Samples are collected from different conditions (e.g., healthy and diseased). Let $Y_{gi}$ denote the observed count of an entity (a leaf on the tree) or a cluster of entities (an internal node on the tree) $g$ in sample $i$. To investigate whether an entity or a cluster of entities has differential abundance under different conditions, currently available packages, such as, `r Biocpkg("edgeR")` and `r Biocpkg("DESeq2")`) could be used. Let's take `r Biocpkg("edgeR")` as an example and explain how our package works.

As assumed in `r Biocpkg("edgeR")`[@Robinson2009], $Y_{gi}$ follows a negative binomial distribution
$$\mathbf{Y}_{gi}  \sim NB(\mathbf{M}_{i}\mathbf{p}_{gj}, \mathbf{\phi}_{g})  $$
$$g = 1, 2, 3, ..., n, n+1, ..., n+K;$$ 
$$i = 1, 2, ... m;$$ 
$$j = 1, 2, ..., J.$$


Here,  $\mathbf{M}_{i}$ is the effective total count of sample $i$, $\mathbf{p}_{gj}$ is the relative abundance of OTU or internal node $g$ in experimental group (or condition) $j$ to which sample $i$ belongs, and $\mathbf{\phi}_{g}$ is the dispersion parameter used to consider the biological variation between samples. The negative binomial distribution is parameterized with mean as $\mathbb{E}[\mathbf{Y}_{gi}] = \mu_{gi} =  \mathbf{M}_{i}\mathbf{p}_{gj}$, and variance as
$\text{Var}[\mathbf{Y}_{gi}] = \mu_{gi}(1+\mu_{gi}\phi_{g})$. When $\mathbf{\phi}_{g} = 0$, the negative binomial distribution reduces to Poisson distribution. In total, we have $n$ entities, $K$ entity clusters, $m$ samples and $J$ conditions.

A generalized linear model could be built at each leaf (an entity) and each internal node (a cluster of entities) of the tree after the value of  $\mathbf{\phi}_{g}$ is estimated,
$$
\text{log}(\mu_{gi}) = \mathbf{x}^{T}_{i} \mathbf{\beta}_{g}, \quad g = 1, 2, ..., n, n+1, ...., n+K
$$
where $\mathbf{x}^{T}_{i}$ is a vector of covariates including confounders (e.g., age, gender) and the covariate of interest (e.g., diseased and healthy sample) applied on sample $i$, and $\mathbf{\beta}_{g}$ is a vector of corresponding regression coefficients. Let $\beta^{1}_{g}$ denote the coefficient value for the covariate of interest in $\beta_{g}$.


We arrange the hypotheses in a tree-like structure and test hypotheses
$$
H^{g}_{0}: \beta^{1}_{g} = 0, (g = 1, 2, ..., n, n+1, ...., n+K ),
$$
where n is the number of tree leaves and K is the number of internal nodes.

The min-P algorithm is implemented to do the tree aggregation as below.

* Test all hypotheses at tree leaves and internal nodes simultaneously and use Benjamin-Hochberg procedure to control the FDR rate.
* Start from the tree leaves. Compare the adjusted p value (or p value) on leaves to that on their parent node. If the minimum value is on the level parent node, take the parent node; otherwise, take the children and compare them to one higher level of their parent.
* Repeat the previous step until reach the root.

Finally, for any internal node in the final result, its descendants all have higher p value than it.



# Application
## Real data

```{r}
library(ggplot2)
library(ape)
library(treeAGG)
```

### Data preparation

To use the `r Biocpkg("treeAGG")` package, two data structures are required: a table of counts of entities (e.g., cell clusters or microbes) across multiple samples, and a hierarchical structure of these entities (e.g., a hierarchical organization of cell clusters or a phylogenetic tree of microbes). Here, we show an example of mass cytometry data, where the entities are cell clusters and the counts represent the number of cells included in each cluster across a number of biological samples. In this example, we would like to investigate on which hierarchical level the cell clusters are differentially abundant between healthy and cancer subjects.

#### Tree 

The tree we use here is the hierarchical structure of cell clusters, obtained by hierarchical clustering of the individual clusters. It's a *hclust* object, provided as part of the `r Biocpkg("treeAGG")` package. 

```{r}
data("cytofTree")
class(cytofTree)
```

To use `r Biocpkg("treeAGG")`, we need to transform the *hclust* object into a *phylo* object, using the *as.phylo* function from the `r CRANpkg("ape")` package [@Paradis2004].

```{r}
pTree <- as.phylo(cytofTree)
class(pTree)
```

#### Count table

```{r}
data("cytofCount")
dim(cytofCount)
head(cytofCount)
```

The count table contains the number of cells in each of the cell clusters across 10 samples, five from healthy subjects and five representing samples from cancer subjects. It's a semi-simulated data set, where one cell population has been spiked in [@Weber2018]. More details are in the help page (`?cytofCount`).

For the count table, each row represents a cell cluster that corresponds to a leaf node in the hierarchical tree, and each column represents a sample. To do tree signal aggregation, we also need counts of the internal nodes of the tree, which indicate different resolutions at which data can be viewed. As *cytofCount* only provides counts at leaf level, we generate counts of internal nodes by summing the counts of their descendants, using the `nodeValue` function as shown below.

```{r}
# the count of an internal node is the sum of its descendant leaves counts.
# the output table has counts for all nodes (both leaf and internal).
count <- nodeValue(data = cytofCount, 
                   tree = pTree,
                   fun = sum)
dim(count)
```


### Data analysis

We arrange the hypothesis in a tree-like structure and for each node in the tree test the hypothesis 
$$H_0 : \text{There is no differential abundance between conditions}.$$

The Bioconductor package `r Biocpkg("edgeR")` is used here as an example to investigate whether an entity shows differential abundance between conditions, but users are free to perform the testing using any suitable software. The only requirement is that the differential testing outputs a multiple testing-adjusted p-value at each tree node, which can be further used to do the aggregation.

```{r}
library(edgeR)
# create DGEList object
#  - overwrite the library size with the sum of counts from leaves.
isLeaf <- !grepl("Node", rownames(count))
y <- DGEList(counts = count, lib.size = colSums(count[isLeaf, ]),
             group = rep(1:2, each = 5), remove.zeros = TRUE)

# TMM normalisation
y <- calcNormFactors(object = y, method = "TMM")

# construct design matrix
grp <- factor(rep(1:2, each = 5))
dm <- model.matrix(~ grp)

# estimate dispersion
y <- estimateGLMRobustDisp(y, design = dm)
fit <- glmFit(y, design = dm)
lrt <- glmLRT(fit)

# multiple testing correction
# n is set to Inf below, because we want to have the results of all entities.
# Benjamin-Hochberg correction is used here.
 
out <- topTags(lrt, n = Inf, adjust.method = "BH")
mod <- out$table

head(mod)
```
 
The output `mod` has multiple columns, one of which is the adjusted p value (named `FDR`). The adjusted p value is obtained via the Benjamini-Hochberg method. We could directly use the `mod` data frame to do the tree aggregation in the next section, or extract only the column `FDR`. One thing should be paid attention to is that `mod` should have entitiy labels as the row names so that the result could be matched correctly to the tree structure.

### Tree aggregation

To do the tree aggregation, we need a hiearchical tree (`ptree`) and a matrix or data frame with a column of adjusted p-values at each node of the tree (`mod`). `pLim` is the threshold for the adjusted p-value to reject the null hypothesis. `varSIG` is the name of the column in *data* that contains the adjusted p-values, and `varAGG` is the name of the column that is used to do the aggregation (here it is also the adjusted p-value).

```{r}
# min - P
outAGG <- treeAGG(tree = pTree, data = mod,
               pLim = 0.05, varSIG = "FDR",
               varAGG = "FDR")
head(outAGG)
```

```{r}
loc <- outAGG$label[outAGG$select]
loc
```
`loc` contains the IDs of the nodes suggested to drive the differential abundance between conditions.

### Results
#### Visualisation

The information about the true differential abundance of cell clusters in our semi-simulated data set is stored in the `cytofTruth` object available in the package (More details could be seen via `?cytofTruth`)

```{r}
data("cytofTruth")
head(cytofTruth)
```

We extract the clusters that are truly differentially abundant (see [@Weber2018]). `cytofTruth` only provides the truth on the leaf level. If a branch has all its leaves differentially abundant, we would ideally like to aggregate the leaves to the top node of the branch, that is, the node connecting this branch and the other part of the tree. 

```{r}
# leaves are differentially abundant (true leaves)
trueTip <- cytofTruth$cluster[cytofTruth$true]

# find branch nodes shared by true leaves.
real <- signalNode(node = trueTip, tree = pTree, label = TRUE)
```

Next, we generate a figure to compare the result with the truth via `treePlot`. (The function `treePlot` is created based on `r Biocpkg("ggtree")`[@Yu2017] and `r CRANpkg("ggplot2")`[@Wickham2016]). The branches with blue edges are truly differentially abundant. The results obtained from the minP algorithm are shown as orange points. Nodes labelled with orange points are the suggested optimal levels at which to interpret the signal. 

```{r}
p <- treePlot(tree = pTree ,  
              branch = real,
              point = loc,
              zoomNode = real,
              layout = "circular")
p
```

To add a legend to the figure, we could use `legend = TRUE` and specify the labels and title for the legend.

```{r}
p <- treePlot(tree = pTree,  
         branch = real,
         point = loc,
         zoomNode = real,
         layout = "circular",
         legend = TRUE, 
         legend.label = list(
           col.branch = "Diff",
           col.other = "Non-diff",
           col.point = "Diff"), 
         legend.title = c(branch = "Truth",
                          point = "Found"))
p

```

#### Evaluation

The evaluation could be performed on the leaf or node level. The leaf level of a node is its descendant leaves. The node level of some specified leaves are leaves themselves and internal nodes having descendant leaves within the specified leaves. 

The true positive rate (TPR) could be calculated on the leaf or node level. On the leaf level, it is the ratio of the number of correctly found leaves to the number of truly differentially abundant leaves.  The calculation of TPR on the node level is similar to that on the leaf level except that the ratio is based on nodes instead of leaves. 

```{r}
# true positive rate at leaf level
(tpr.l <- tpr(tree = pTree, truth = trueTip, 
             found = loc, level = "leaf"))
# true positive rate at leaf level
(tpr.n <- tpr(tree = pTree, truth = trueTip, 
             found = loc, level = "node"))
```

The false discovery rate (FDR) could be calculated on the leaf or node level. On the leaf level, it is the ratio of the number of falsely found leaves to the number of found leaves.  The calculation of FDR on the node level is similar to that on the leaf level except that the ratio is based on nodes instead of leaves. 


```{r}
# true positive rate at leaf level
(fdr.l <- fdr(tree = pTree, truth = trueTip, 
             found = loc, level = "leaf"))
# true positive rate at leaf level
(fdr.n <- fdr(tree = pTree, truth = trueTip, 
             found = loc, level = "node"))
```

## Simulation

`r Biocpkg("treeAGG")` provides the function `doTable` to simulate different signal patterns by swapping the signal strength (relative count) of two branches.

* scenario one (S1): full signal on two selected branches. Signals within each of the two branches (or clusters) have the same sign and strength.
* scenario two (S2): full signal on two selected branches. Signals within each of the two branches (or clusters) have the same sign but different strength.
* scenario three (S3): one branch has full signal, but the others only have partial signal. Signals within each of the two branches (or clusters) have the same sign and strength.

Full signal means that the counts for all leaves on the branch are modified. Partial signal means that only some leaves evenly distributed on that branch have signal.

To simulate a count table using `doTable`, one needs to provide a real hiearchical structure and a real count table of entities. Here, we use a real throat microbiome data set that includes a count table of 856 OTUs (operational taxonomic units) from 60 samples and a phylogenetic tree with 856 leaves and 855 internal nodes [@Charlson2010]. More details about the data could be seen via `?GUniFrac::throat.tree` and `?GUniFrac::throat.otu.tab`.

```{r}
library(GUniFrac)
```

```{r}
data("throat.tree")
data("throat.otu.tab")
```

### Signal branches known

If we already know for which two branches we want to swap the signals, we can feed `doTable` the real data via two arguments `tree` and `data`, and these branches via `from.A` and `from.B` as below. `throat.otu.tab` has the samples in the row and entities in the column, so we need to transpose it before input to `doTable`.

```{r}
# simulate count table
dat0 <- doTable(tree = throat.tree,
                data = as.matrix(t(throat.otu.tab)),
                from.A = 1671,
                from.B = 1613)

str(dat0)
```

The result, `dat0`, is a list including a simulated count table (`Count`), a vector of fold changes for all entities on tree leaf level (`FC`), the information of branches where signals are given (`Branch`), and the simulation scenario (`Scenario`).

```{r}
bb0 <- c(dat0$Branch$A, dat0$Branch$B)

treePlot(tree = throat.tree, branch = bb0, 
         col.branch = c("orange", "blue"), 
         zoomNode = bb0, 
         zoomScale = 20, legend = TRUE, 
         legend.label = list(
           col.branch = c("increase", "decrease")),
         legend.title = c(branch = "Truth"),
         layout = "rectangular",
         legend.theme = list(legend.position = c(0.2, 0.6)))
```

### Signal branches unknown

If we have not decided yet where to put signal or only decide one branch, we can let `doTable` select the branches. 

The estimate of parameters from the real data takes a while. In the following part, we will do simulation several times based on the same real data. To save time, we will firstly do the parameter estimation and use it as the argument `data` in the `doTable` function to avoid the repetition. One could also directly use the count table for `data`.

```{r}
# estimate the parameters
throat.par <- parEstimate(data = t(throat.otu.tab))
```

Set seed to have reproducible result.

```{r}
set.seed(1122)
```

```{r}
# simulate count table
dat1 <- doTable(tree = throat.tree,
               data = throat.par,
               ratio = 2)
```

To visualize the signal pattern on the tree structure, one could do it as below. 

```{r}
bb1 <- c(dat1$Branch$A, dat1$Branch$B)
treePlot(tree = throat.tree, branch = bb1, 
         col.branch = c("orange", "blue"), 
         zoomNode = bb1, 
         zoomScale = 50, legend = TRUE, 
         legend.label = list(
           col.branch = c("increase", "decrease")),
         legend.title = c(branch = "Truth"),
         layout = "rectangular",
         legend.theme = list(legend.position = c(0.2, 0.6)))
```

If we want to limit the set of branches that can be selected for the signal swapping to only those where the number of leaves is in a given interval, it can be achieved by changing the values of `minTip.A`, `maxTip.A`, `minTip.B` and `maxTip.B`.

```{r}
dat2 <- doTable(tree = throat.tree,
                data = throat.par, 
                minTip.A = 20, maxTip.A = 40,
                minTip.B = 20, maxTip.B = 100,
                ratio = 2)
```

```{r}
bb2 <- c(dat2$Branch$A, dat2$Branch$B)
treePlot(tree = throat.tree, branch = bb2, 
         col.branch = c("orange", "blue"), 
         zoomNode = bb2, layout = "rectangular", 
         zoomScale = 10, legend = TRUE, 
         legend.label = list(
           col.branch = c("increase", "decrease")),
         legend.title = c(branch = "Truth"),
         legend.theme = list(legend.position = c(0.2, 0.6)))
```

Similarly, if one would like to select branches with a certain abundance level, it can be done via `minPr.A` and `maxPr.A`. These two arguments restrict the count proportion level of branch A. One could combine using these two arguments with `ratio` to restrict the branch B.

```{r}
dat3 <- doTable(tree = throat.tree,
                data = throat.par, 
                minTip.A = 20, maxTip.A = 40,
                minTip.B = 20, maxTip.B = 100, 
                maxPr.A = 0.01,
                ratio = 2)
rb <- rbind(dat2$Branch, dat3$Branch)
rownames(rb) <- c("dat2", "dat3")
rb
```

The ratio in `dat3` is `r dat3$Branch$ratio`, which is different from the value given to the argument `ratio = 2`. It's because there is not any pair of branches which has ratio exactly equal to 2. The pair having the value closest to 2 will be returned.

If one want to put signal on a specific branch, `from.A` can be used. 

```{r}
dat4 <- doTable(from.A = dat3$Branch$A,
                tree = throat.tree,
                data = throat.par, 
                minTip.A = 20, maxTip.A = 40,
                minTip.B = 20, maxTip.B = 100, 
                maxPr.A = 0.01,
                ratio = 4)
rbind(dat3$Branch, dat4$Branch)
```

Branch A in `dat3` and `dat4` are the same. 

One could simulate different signal patterns by changing the `scenario`.

```{r}
dat5 <- doTable(from.A = dat4$Branch$A,
                from.B = dat4$Branch$B,
                scenario = "S3",
                tree = throat.tree,
                data = throat.par)
```

```{r}
bb5 <- names(dat5$FC)[dat5$FC != 1]
bh <- signalNode(node = bb5, tree = throat.tree)
bl <- transNode(tree = throat.tree, input = bh)
cc <- ifelse(bl == dat5$Branch$B, "blue", "orange")
p1 <- treePlot(
  tree = throat.tree,
  branch = bh,
  col.branch = cc,
  zoomNode = c(dat5$Branch$A,
               dat5$Branch$B),
  layout = "rectangular",
  zoomScale = 20,
  legend = TRUE,
  legend.label = list(
    col.branch = c(rep("increase", length(cc) - 1),
                   "decrease"),
    col.other = "same"),
  legend.title = c(branch = "Truth"),
  legend.theme = list(legend.position = c(0.2, 0.6)))

bb4 <- c(dat4$Branch$A, dat4$Branch$B)
p2 <- treePlot(tree = throat.tree, 
               branch = bb4, 
               col.branch = c("orange", "blue"), 
               zoomNode = bb4, layout = "rectangular", 
               zoomScale = 10, legend = TRUE, 
               legend.label = list(
                 col.branch = c("increase", "decrease")),
               legend.title = c(branch = "Truth"),
               legend.theme = list(
                 legend.position = c(0.2, 0.6)))
```

```{r}
library(cowplot)
plot_grid(p1, p2, labels = c("S3", "S1"))
```

## References
