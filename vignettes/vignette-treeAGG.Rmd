---
title: "Tree Aggregation"
author: 
- name: Ruizhu HUANG
  affiliation: 
  - Institute of Molecular Life Science, University of Zurich.
  - SIB Swiss Institute of Bioinformatics.
package: treeAGG
output: 
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Tree Aggregation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---




```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(ape)
library(treeAGG)
```

\newpage 

In this Vignette, I use the data generated by Lukas as an example to show how to use the **treeAGG** package. 


# Data preparation
## The tree 


The tree data created by Lukas from the cytometry data is a hclust object. To use treeAGG, we need to firstly transform it into a phylo object.


```{r}
data("simTree")
class(simTree)
pTree <- as.phylo(simTree)
class(pTree )

```



We further prune the tree at each internal node into subtrees. The results are output as a list of phylo objects, each representing a subtree. This step is not obligatory. The list of subtrees is required later for tree aggregation. It could be generated automatically in the aggregation R functions, but the cutting could take a lot of time if the tree has huge size. To run it once and save it for later use would save a lot of time.

```{r}
# prune tree
system.time(
phylo_small <- pruneTree(pTree )
)

```


## The count table

A count table with each row representing a node in the tree and each column representing a sample is required. If data only provides the count at tree leaf nodes, we could use the following code to generate a count table for the whole tree.

```{r}
data("simCount")
head(simCount)

# generate the count table for the whole tree (including leaves and internal nodes)
# the count of an internal node is the sum of counts on its descendant leaves.
allCount <- nodeCount(tipTable = simCount, tree = pTree ,
                      stree = phylo_small, fun = sum)
dim(allCount)
```


# Data analysis

We arrange the hypothesis in a tree-like structure and test hypotheses
$H_0 : \text{There is not differential abundance}$ at each node (interal node and leaf node) of the tree.

R package **edgeR** is used here to investigate whether an entity has differential abundance among conditions. Users are free to choose other R packages to do the analysis. Finally, we obtain a p value at each node of the tree and further use them to do tree aggregation.
 
```{r}

isNode <- grepl("Node", rownames(allCount))
mod_edgeR <- runEdgeR(countTab = allCount, nSam = c(5,5), 
                   isTip = !isNode, isAnalyze = rep(TRUE, nrow(allCount)),
                   prior.count = 0, normalize = TRUE)
head(mod_edgeR)
```



The output has multiple columns, one of which is the adjusted p value named \textit{FDR}. The adjusted p value is obtained via Benjamin-Hochberg method. We could directly use the $mod\_edgeR$ to do the tree aggregation in the next section or extract only the column \textit{FDR}.

# Tree aggregation

To do tree aggregation, we need a hiearchical tree ($phylo\_out$), and a matrix or data frame with a column of adjusted p vlaues at each node of the tree ($mod\_edgeR$). The subtrees of the hiearchical tree (phylo_small) could be provided to save time. If stree is set as NULL, the list of subtrees would be generated automatically.


```{r}
# min - P
loc_edgeR <- treeAGG(tree = pTree , data = mod_edgeR,
                     stree = phylo_small, P.lim = 0.05, 
                     varSIG = "FDR", varAGG = "FDR")
loc_edgeR

```

* Item 1 wtree is the hiearchical tree of the entities (such as OTUs or cells).
* Item 2 data is the data frame including at least a column of adjusted p values for all nodes of hiearchical tree.
* Item 3 stree is a list of subtrees of the hiearchical tree.
* Item 4 P.lim is the significant threshold value for the adjusted p value.
* Item 5 varSIG is the column name of the adjusted p value.
* Item 6 varAGG is the column name of the variable the aggregation based on. Here, we also use the adjusted p value.

# Results
## visualisation

```{r}
data("simTruth")
trueTip <-simTruth$cluster[simTruth$true]
real <- signalNode(node = trueTip, tree = pTree, label = TRUE)

p <- treePlot(tree = pTree ,  
              branch = real,
              col.branch = c("Diff" = "blue"), 
              col.other = c("Non-diff" = "darkgrey"),
              size.point = 2, 
              size.line.legend = 2,
              size.point.legend = 2,  
              point = loc_edgeR,
              col.point = c(found = "orange"),
              zoomNode = real, 
              zoomScale = 8,
              legend.title = c("point" = "Estimate",
                               "branch" = "Truth"),
              layout = "circular")

p+
  ggplot2::theme(legend.position = "right",
                 legend.text = element_text(size= 12),
                 legend.key.size = unit(4,"cm"),
                 legend.key.height = unit(0.4,"cm"),
                 legend.key.width = unit(0.5, "cm"),
                 legend.title = element_text(size = 15),
                 legend.background = element_rect(),
                 legend.box.background = element_rect(colour = "black"))


```

## Evaluation

The true positive rate at leaf level is the ratio of the number of correctly found leaves to the number of leaves with true differential abundance.

```{r}
# true positive rate at leaf level
(rateL <- tpr(tree = pTree, truth = trueTip, 
             found = loc_edgeR, level = "leaf"))

```
The true positive rate at node level is the ratio of the number of correctly found nodes to the number of nodes with true differential abundance.

```{r}
# true positive rate at leaf level
(rateN <- tpr(tree = pTree, truth = trueTip, 
             found = loc_edgeR, level = "node"))

```
