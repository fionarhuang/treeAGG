---
title: "Tree Aggregation"
author: 
- name: Ruizhu HUANG
  affiliation: 
  - Institute of Molecular Life Science, University of Zurich.
  - SIB Swiss Institute of Bioinformatics.
package: treeAGG
output: 
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Tree Aggregation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---




```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(ape)
library(treeAGG)
```

# Real data
## Data preparation

To use package **treeAGG**, two data structures are required: a count table of entities (e.g., cell clusters or micobes) and a hiearchical structure of entities. Here, we show an example of cytometry data. In this example, we would like to investigate on which hiearchical level the cell clusters are differentially abundant between healthy and cancer subjects.

### Tree 

The tree we use here is the hiearchical structure of cell clusters. It's a *hclust* object. To use treeAGG, we need to transform it into a phylo object using *as.phylo* from **ape** package.


```{r}
data("simTree")
class(simTree)
pTree <- as.phylo(simTree)
class(pTree)

```

### Count table

```{r}
data("simCount")
?simCount
head(simCount)
```

The count table includes 10 samples, five from healthy subjects and five representing samples from cancer subjects. It's a semi-simulated data. More details are in the data help page.

```{r eval=FALSE}
?simCount
```

In the count table, each row represents a cell cluster that corresponds to a leaf node in the tree structure, and each column represents a sample. To do tree signal aggregation, we also need couts of the tree internal nodes, which indicates different resolutions at which data can be viewed. As *simCount* only provides counts at leaf level, we could generate counts for internal nodes using the codes below.

```{r}
# the count of an internal node is the sum of its descendant leaves counts.
# the output table has counts for all nodes (both leaf and internal).
count <- nodeCount(data = simCount, tree = pTree,
                      fun = sum)
dim(count)
```


## Data analysis

We arrange the hypothesis in a tree-like structure and test hypotheses
$H_0 : \text{There is not differential abundance}$ at each node (interal node and leaf node) of the tree.

R package **edgeR** is used here to investigate whether an entity has differential abundance among conditions. Users are free to choose other R packages to do the analysis. What we need is to obtain a p value at each tree node and further use them to do aggregation.
 
```{r}
# rows for internal nodes
isNode <- grepl("Node", rownames(count))
mod <- runEdgeR(data = count, 
                nSam = c(5,5), 
                isTip = !isNode,
                prior.count = 0,
                normalize = TRUE)
head(mod)
```

The output has multiple columns, one of which is the adjusted p value named \textit{FDR}. The adjusted p value is obtained via Benjamin-Hochberg method. We could directly use the *mod* to do the tree aggregation in the next section or extract only the column *FDR*.

## Tree aggregation

To do tree aggregation, we need a hiearchical tree ($ptree$), and a matrix or data frame with a column of adjusted p values at each node of the tree ($mod$). *P.lim* is the threshold for the adjusted p value to reject null hypothesis. *varSIG* is the name of the column in *data* which has the adjusted p value, and *varAGG* is the name of the colum which is used to do aggregation (here is also adjusted p value).


```{r}
# min - P
loc <- treeAGG(tree = pTree, data = mod,
               P.lim = 0.05, varSIG = "FDR",
               varAGG = "FDR")
loc

```


## Results
### visualisation

The information about the differential abundance of cell clusters is stored in data called *simTruth* (More details could be seen via \code{?simTruth})

```{r}
data("simTruth")
head(simTruth)
```

Extract the clusters that are truly differentially abundant. *simTruth* only provides the information on the leaf level. If a branch has all its leaves differentially abundant, we would like to find its branch node, the node connecting this branch and the other part of the tree, as a representative.

```{r}
# leaves are differentially abundant (true leaves)
trueTip <-simTruth$cluster[simTruth$true]

# find branch nodes shared by true leaves.
real <- signalNode(node = trueTip, tree = pTree, label = TRUE)
```

Compare the result found with the truth. The branches with blue edges are truly differentially abundant. The results obtained from the minP algorithm are shown as orange points. If an internal node is labelled with an orange point, it means that all its descendant nodes are found to be differentially abundant. In other words, that whole branch is found to have signal. 

```{r}
p <- treePlot(tree = pTree ,  
              branch = real,
              point = loc,
              zoomNode = real,
              layout = "circular")
p
```

To add legend to the figure, we could use \code{legend = TRUE} and specify the labels and title for the legend.
```{r}
p <- treePlot(tree = pTree,  
         branch = real,
         point = loc,
         zoomNode = real,
         layout = "circular",
         legend = TRUE, 
         legend.label = list(
           col.branch = "Diff",
           col.other = "Non-diff",
           col.point = "Diff"), 
         legend.title = c(branch = "Truth",
                          point = "Found"))
p

```


### Evaluation

The true positive rate at leaf level is the ratio of the number of correctly found leaves to the number of true leaves.

```{r}
# true positive rate at leaf level
(tpr.l <- tpr(tree = pTree, truth = trueTip, 
             found = loc, level = "leaf"))
# true positive rate at leaf level
(tpr.n <- tpr(tree = pTree, truth = trueTip, 
             found = loc, level = "node"))

```

The true positive rate at node level is the ratio of the number of correctly found nodes to the number of true nodes.

```{r}
# true positive rate at leaf level
(fdr.l <- fdr(tree = pTree, truth = trueTip, 
             found = loc, level = "leaf"))
# true positive rate at leaf level
(fdr.n <- fdr(tree = pTree, truth = trueTip, 
             found = loc, level = "node"))

```
