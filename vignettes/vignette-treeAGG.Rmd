---
title: "Tree Aggregation"
author: 
- name: Ruizhu HUANG
  affiliation: 
  - Institute of Molecular Life Science, University of Zurich.
  - SIB Swiss Institute of Bioinformatics.
package: treeAGG
output: 
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Tree Aggregation}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---




```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

# Real data

```{r}
library(ggplot2)
library(ape)
library(treeAGG)
```

## Data preparation

To use package **treeAGG**, two data structures are required: a count table of entities (e.g., cell clusters or micobes) and a hiearchical structure of entities. Here, we show an example in cytometry data. In this example, we would like to investigate on which hiearchical level the cell clusters are differentially abundant between samples collected from healthy and cancer subjects.

### Tree 

Here, a tree is a hiearchical structure of cell clusters. It's a `hclust` object. 


```{r}
data("simTree")
class(simTree)
```

To use treeAGG, we need to transform it into a phylo object using `as.phylo` from **ape** package.

```{r}
pTree <- as.phylo(simTree)
class(pTree)
```

### Count table

```{r}
data("simCount")
dim(simCount)
head(simCount)
```

The count table includes 10 samples, five from healthy subjects and five representing samples from cancer subjects. It's a semi-simulated data. More details are in the help page (`?simCount`).

For count table, each row represents a cell cluster that corresponds to a tree leaf node, and each column represents a sample. To do tree signal aggregation, we also need couts of internal nodes, which indicates different resolutions at which data can be viewed. As `simCount` only provides counts at leaf level, we could generate counts of internal nodes as below.

```{r}
# the count of an internal node is the sum of its descendant leaves counts.
# the output table has counts for all nodes (both leaf and internal).
count <- nodeCount(data = simCount, tree = pTree,
                      fun = sum)
dim(count)
```


## Data analysis

We arrange the hypothesis in a tree-like structure and test hypotheses at each node of the tree.
$H_0 : \text{There is not differential abundance between conditions}$ .

R package **edgeR** is used here to investigate whether an entity has differential abundance among conditions. Users are free to choose other R packages to do analysis. What we need is to obtain a p value at each node and further use them to do aggregation.
 
```{r}
# rows for internal nodes
isNode <- grepl("Node", rownames(count))
mod <- runEdgeR(data = count, 
                nSam = c(5,5), 
                isTip = !isNode,
                prior.count = 0,
                normalize = TRUE)
head(mod)
```

The output has multiple columns, one of which is the adjusted p value named `FDR`. The adjusted p value is obtained via Benjamin-Hochberg method. We could directly use the `mod` to do the tree aggregation in the next section or extract only the column `FDR`.

## Tree aggregation

`treeAGG` is used to do tree aggregation. A hiearchical tree (`ptree`) and a matrix with a column of adjusted p values at each node (`mod`) are input to the function. `P.lim` is a threshold value to reject null hypothesis. `varSIG` is the name of the column in `data` storing the adjusted p value. `varAGG` is the name of the column for aggregation (here is also adjusted p value).


```{r}
# min - P
loc <- treeAGG(tree = pTree, data = mod,
               P.lim = 0.05, varSIG = "FDR",
               varAGG = "FDR")
loc

```

`loc` is the level suggested to drive the differential abundance between conditions.

## Results
### visualisation

The truth about the differential abundance of cell clusters is stored in data called `simTruth` (More details could be seen via `?simTruth`)

```{r}
data("simTruth")
head(simTruth)
```

Extract the clusters that are truly differentially abundant. `simTruth` only provides the truth the leaf level. If a branch has all its leaves differentially abundant, we would like to find its branch node, the node connecting this branch and the other part of the tree, as a representative. 

```{r}
# leaves are differentially abundant (true leaves)
trueTip <-simTruth$cluster[simTruth$true]

# find branch nodes shared by true leaves.
real <- signalNode(node = trueTip, tree = pTree, label = TRUE)
```

Compare the result with the truth. The branches with blue edges are truly differentially abundant. The results obtained from the minP algorithm are shown as orange points. If an internal node is labelled with an orange point, it means that all its descendant nodes are found to be differentially abundant. In other words, the whole branch is found to have signal. 

```{r}
p <- treePlot(tree = pTree ,  
              branch = real,
              point = loc,
              zoomNode = real,
              layout = "circular")
p
```

To add legend to the figure, we could use `legend = TRUE` and specify the labels and title for the legend.
```{r}
p <- treePlot(tree = pTree,  
         branch = real,
         point = loc,
         zoomNode = real,
         layout = "circular",
         legend = TRUE, 
         legend.label = list(
           col.branch = "Diff",
           col.other = "Non-diff",
           col.point = "Diff"), 
         legend.title = c(branch = "Truth",
                          point = "Found"))
p

```


### Evaluation

The true positive rate at leaf level is the ratio of the number of correctly found leaves to the number of true leaves.

```{r}
# true positive rate at leaf level
(tpr.l <- tpr(tree = pTree, truth = trueTip, 
             found = loc, level = "leaf"))
# true positive rate at leaf level
(tpr.n <- tpr(tree = pTree, truth = trueTip, 
             found = loc, level = "node"))

```

The true positive rate at node level is the ratio of the number of correctly found nodes to the number of true nodes.

```{r}
# true positive rate at leaf level
(fdr.l <- fdr(tree = pTree, truth = trueTip, 
             found = loc, level = "leaf"))
# true positive rate at leaf level
(fdr.n <- fdr(tree = pTree, truth = trueTip, 
             found = loc, level = "node"))

```


# Simulation

**treeAGG** provides the function `doTable` to simulate different signal patterns.

* scenario one (S1): full signal on two selected branches. Signals within each of the two branches (or clusters) have the same sign and strength.
* scenario two (S2): full signal on two selected branches. Signals within each of the two branches (or clusters) have the same sign but different strength.
* scenario three (S3): one branch have full signal, but the other only have partial signal. Signals within each of the two branches (or clusters) have the same sign and strength.

Full signal means that all leaves on the branch have signal. Partial signal means that only some leaves evenly distributed on that branch have signal.

To simulated a count table using `doTable`, one needs to provide a real hiearchical structure and a real count table of entities. Here, we use a real throat microbiome data set that includes a count table of 856 OTUs (operational taxonomic units) from 60 samples and a phylogenetic tree with 856 leaves and 855 internal nodes. More details about the data could be seen via `?throat.tree` and `?throat.otu.tab`.

```{r}
library(GUniFrac)
```

```{r}
data("throat.tree")
data("throat.otu.tab")
```

## Signal branches known

If we already decide the branches to put signal, we could feed `doTable` the real data via two arguments `tree` and `data`, and the branches via `from.A` and `from.B` as below.

```{r}
# simulate count table
dat0 <- doTable(tree = throat.tree,
               data = as.matrix(t(throat.otu.tab)),
               from.A = 1671,
               from.B = 1613
               )
```

`throat.otu.tab` has the samples in the row and entities in the column, so we need to tranpose it before input to `doTable`.

```{r}
str(dat0)
```

The result, `dat` is a list including a simulated count table (`Count`), a vector of fold change for all entities on tree leaf level (`FC`), the information of branches where signals are given (`Branch`), and the scenario (`Scenario`).

```{r}
bb0 <- c(dat0$Branch$A, dat0$Branch$B)

treePlot(tree = throat.tree, branch = bb0, 
         col.branch = c("orange", "blue"), 
         zoomNode = bb0, 
         zoomScale = 20, legend = TRUE, 
         legend.label = list(
           col.branch = c("increase", "decrease")),
         legend.title = c(branch = "Truth"),
         layout = "rectangular",
         legend.theme = list(legend.position = c(0.2, 0.6)))
```

## Signal branches unknown

If we have not decided yet where to put signal or only decide one branch, we could let `doTable` to select the branches. 

The estimate of parameters from the real data takes a while. In the following part, we will do simulation several times based on the same real data. To save time, we will firstly do the parameter estimation and use it as the argument `data` in the `doTable` function to avoid the repetition. One could also directly use the count table for `data`.

```{r}
# estimate the parameters
throat.par <- parEstimate(data = t(throat.otu.tab))
```

Set seed to have reproduciable result.
```{r}
set.seed(1122)
```


```{r}
# simulate count table
dat1 <- doTable(tree = throat.tree,
               data = throat.par,
               ratio = 2)
```


To visualize signal pattern on the tree structure, one could do it as below. 

```{r}
bb1 <- c(dat1$Branch$A, dat1$Branch$B)
treePlot(tree = throat.tree, branch = bb1, 
         col.branch = c("orange", "blue"), 
         zoomNode = bb1, 
         zoomScale = 50, legend = TRUE, 
         legend.label = list(
           col.branch = c("increase", "decrease")),
         legend.title = c(branch = "Truth"),
         layout = "rectangular",
         legend.theme = list(legend.position = c(0.2, 0.6))
         )
```

If one wants to add signals on branches with more leaves, it could be achieved by changing the value for `minTip.A`, `maxTip.A`, `minTip.B` and `maxTip.B`.

```{r}
dat2 <- doTable(tree = throat.tree,
               data = throat.par, 
               minTip.A = 20, maxTip.A = 40,
               minTip.B = 20, maxTip.B = 100,
               ratio = 2)
```

```{r}
bb2 <- c(dat2$Branch$A, dat2$Branch$B)
treePlot(tree = throat.tree, branch = bb2, 
         col.branch = c("orange", "blue"), 
         zoomNode = bb2, layout = "rectangular", 
         zoomScale = 10, legend = TRUE, 
         legend.label = list(
           col.branch = c("increase", "decrease")),
         legend.title = c(branch = "Truth"),
         legend.theme = list(legend.position = c(0.2, 0.6))
         )
```

If one would like to select branches with a certain abundance level, it could be done via `minPr.A` and `maxPr.A`. These two arguments restrict the count proportion level of branch A. One could combine using these two arguments with `ratio` to restrict the branch B.


```{r}
dat3 <- doTable(tree = throat.tree,
               data = throat.par, 
               minTip.A = 20, maxTip.A = 40,
               minTip.B = 20, maxTip.B = 100, 
               maxPr.A = 0.01,
               ratio = 2)
rb <- rbind(dat2$Branch, dat3$Branch)
rownames(rb) <- c("dat2", "dat3")
rb
```

The ratio in `dat3` is `r dat3$Branch$ratio` different to the value given to the argument `ratio = 2`. It's because there is not any pair of branches which has ratio exactly equal to 2. The pair having the value closest to 2 would be returned.

If one want to put signal on a specific branch, `from.A` could be used. 

```{r}
dat4 <- doTable(from.A = dat3$Branch$A,
               tree = throat.tree,
               data = throat.par, 
               minTip.A = 20, maxTip.A = 40,
               minTip.B = 20, maxTip.B = 100, 
               maxPr.A = 0.01,
               ratio = 4)
rbind(dat3$Branch, dat4$Branch)
```
Branch A in `dat3` and `dat4` are the same. 

One could simulate different signal patterns by changing the `scene`.

```{r}
dat5 <- doTable(from.A = dat4$Branch$A,
                from.B = dat4$Branch$B,
                scene = "S3",
               tree = throat.tree,
               data = throat.par)

```

```{r}
bb5 <- names(dat5$FC)[dat5$FC != 1]
bh <- signalNode(node = bb5, tree = throat.tree)
bl <- transNode(tree = throat.tree, input = bh)
cc <- ifelse(bl == dat5$Branch$B, "blue", "orange")
p1 <- treePlot(
  tree = throat.tree,
  branch = bh,
  col.branch = cc,
  zoomNode = c(dat5$Branch$A,
  dat5$Branch$B),
  layout = "rectangular",
  zoomScale = 20,
  legend = TRUE,
  legend.label = list(
    col.branch = c(rep("increase", length(cc) - 1),
                   "decrease"),
    col.other = "same"),
  legend.title = c(branch = "Truth"),
 legend.theme = list(legend.position = c(0.2, 0.6))
  )

bb4 <- c(dat4$Branch$A, dat4$Branch$B)
p2 <- treePlot(tree = throat.tree, 
               branch = bb4, 
               col.branch = c("orange", "blue"), 
               zoomNode = bb4, layout = "rectangular", 
               zoomScale = 10, legend = TRUE, 
               legend.label = list(
                    col.branch = c("increase", "decrease")),
               legend.title = c(branch = "Truth"),
               legend.theme = list(
                 legend.position = c(0.2, 0.6)))

```

```{r}
library(cowplot)
plot_grid(p1, p2, labels = c("S3", "S1"))
```
